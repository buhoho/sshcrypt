#!/usr/bin/env python3
"""
sshcrypt - Encrypt/decrypt files using SSH Agent
Simple and elegant file encryption using SSH keys.
"""

import sys
import os
import tempfile
import subprocess
import hashlib
import struct
import socket
from pathlib import Path


# 固定文字列 (署名用)
MAGIC = b"sshcrypt-v1"


class SSHAgent:
    """SSH Agent との通信"""
    
    SSH_AGENTC_REQUEST_IDENTITIES = 11
    SSH_AGENT_IDENTITIES_ANSWER = 12
    SSH_AGENTC_SIGN_REQUEST = 13
    SSH_AGENT_SIGN_RESPONSE = 14
    
    def __init__(self):
        self.sock_path = os.environ.get('SSH_AUTH_SOCK')
        if not self.sock_path:
            raise RuntimeError("SSH_AUTH_SOCK not set. Is ssh-agent running?")
    
    def _send(self, msg):
        """メッセージを SSH Agent に送信"""
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(self.sock_path)
        
        # メッセージ長 + メッセージ
        msg_len = struct.pack('>I', len(msg))
        sock.sendall(msg_len + msg)
        
        # レスポンス受信
        resp_len = struct.unpack('>I', sock.recv(4))[0]
        resp = sock.recv(resp_len)
        sock.close()
        return resp
    
    def get_identities(self):
        """SSH Agent から鍵のリストを取得"""
        msg = bytes([self.SSH_AGENTC_REQUEST_IDENTITIES])
        resp = self._send(msg)
        
        if resp[0] != self.SSH_AGENT_IDENTITIES_ANSWER:
            raise RuntimeError("Failed to get identities")
        
        # 鍵の数
        num_keys = struct.unpack('>I', resp[1:5])[0]
        
        keys = []
        offset = 5
        for _ in range(num_keys):
            # 鍵の長さ
            key_len = struct.unpack('>I', resp[offset:offset+4])[0]
            offset += 4
            
            # 鍵データ
            key_blob = resp[offset:offset+key_len]
            offset += key_len
            
            # コメントの長さ
            comment_len = struct.unpack('>I', resp[offset:offset+4])[0]
            offset += 4
            
            # コメント
            comment = resp[offset:offset+comment_len].decode('utf-8', errors='ignore')
            offset += comment_len
            
            keys.append({'blob': key_blob, 'comment': comment})
        
        return keys
    
    def sign(self, key_blob, data):
        """SSH Agent に署名を依頼"""
        # メッセージ構築
        msg = bytes([self.SSH_AGENTC_SIGN_REQUEST])
        msg += struct.pack('>I', len(key_blob)) + key_blob
        msg += struct.pack('>I', len(data)) + data
        msg += struct.pack('>I', 0)  # flags
        
        resp = self._send(msg)
        
        if resp[0] != self.SSH_AGENT_SIGN_RESPONSE:
            raise RuntimeError("Failed to sign data")
        
        # 署名の長さ
        sig_len = struct.unpack('>I', resp[1:5])[0]
        signature = resp[5:5+sig_len]
        
        return signature


def encrypt_file(plaintext_path, encrypted_path):
    """ファイルを暗号化"""
    agent = SSHAgent()
    keys = agent.get_identities()
    
    if not keys:
        raise RuntimeError("No SSH keys found in agent")
    
    # 最初の鍵を使用
    key = keys[0]
    print(f"Using key: {key['comment']}", file=sys.stderr)
    
    # SSH Agent に署名させる (固定文字列を署名)
    signature = agent.sign(key['blob'], MAGIC)
    
    # 署名から AES 鍵を導出
    aes_key = hashlib.sha256(signature).digest()
    
    # openssl で暗号化
    with open(plaintext_path, 'rb') as f:
        plaintext = f.read()
    
    # openssl を使って暗号化
    proc = subprocess.Popen(
        ['openssl', 'enc', '-aes-256-cbc', '-pbkdf2', '-pass', 'stdin'],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE
    )
    
    encrypted, stderr = proc.communicate(input=aes_key.hex().encode() + b'\n' + plaintext)
    
    if proc.returncode != 0:
        raise RuntimeError(f"openssl encryption failed: {stderr.decode()}")
    
    # ファイルに保存: key_blob_len + key_blob + 暗号化データ
    with open(encrypted_path, 'wb') as f:
        f.write(struct.pack('>I', len(key['blob'])))
        f.write(key['blob'])
        f.write(encrypted)
    
    print(f"Encrypted: {plaintext_path} -> {encrypted_path}", file=sys.stderr)


def decrypt_file(encrypted_path, plaintext_path):
    """ファイルを復号"""
    agent = SSHAgent()
    
    with open(encrypted_path, 'rb') as f:
        # ヘッダー読み取り
        key_blob_len = struct.unpack('>I', f.read(4))[0]
        key_blob = f.read(key_blob_len)
        
        # 暗号化データ
        encrypted = f.read()
    
    # SSH Agent に署名させる (固定文字列を署名)
    signature = agent.sign(key_blob, MAGIC)
    
    # 署名から AES 鍵を導出
    aes_key = hashlib.sha256(signature).digest()
    
    # openssl で復号
    proc = subprocess.Popen(
        ['openssl', 'enc', '-d', '-aes-256-cbc', '-pbkdf2', '-pass', 'stdin'],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE
    )
    
    plaintext, stderr = proc.communicate(input=aes_key.hex().encode() + b'\n' + encrypted)
    
    if proc.returncode != 0:
        raise RuntimeError(f"openssl decryption failed: {stderr.decode()}")
    
    with open(plaintext_path, 'wb') as f:
        f.write(plaintext)
    
    print(f"Decrypted: {encrypted_path} -> {plaintext_path}", file=sys.stderr)


def edit_file(file_path):
    """ファイルを編集"""
    editor = os.environ.get('EDITOR', 'vim')
    tmp_fd, tmp_path = tempfile.mkstemp(suffix='.txt')
    os.close(tmp_fd)
    
    try:
        # 既存ファイルなら復号
        if Path(file_path).exists():
            decrypt_file(file_path, tmp_path)
        else:
            print(f"Creating new file: {file_path}", file=sys.stderr)
        
        # エディタで編集
        subprocess.run([editor, tmp_path])
        
        # 暗号化リトライループ
        while True:
            try:
                encrypt_file(tmp_path, file_path)
                break  # 成功したらループ抜ける
            except Exception as e:
                print(f"\nError: Failed to encrypt", file=sys.stderr)
                print(f"  {e}", file=sys.stderr)
                print("\nPlease fix SSH Agent:", file=sys.stderr)
                print("  - Start: eval $(ssh-agent -s)", file=sys.stderr)
                print("  - Load key: ssh-add ~/.ssh/id_ed25519", file=sys.stderr)
                print("\nPress Enter to retry...", file=sys.stderr)
        
                try:
                    input()
                    # エディタ再起動
                    subprocess.run([editor, tmp_path])
                except KeyboardInterrupt:
                    # 1回目の Ctrl+C: 警告
                    print("\n\nWarning: Pressing Ctrl+C again will DELETE the temp file permanently.", file=sys.stderr)
                    print(f"Temp file location: {tmp_path}", file=sys.stderr)
                    print("\nIf you need to save it, copy it now.", file=sys.stderr)
                    print("Press Enter to continue editing, or Ctrl+C again to delete and exit.", file=sys.stderr)
                    try:
                        input()
                        # エディタ再起動
                        subprocess.run([editor, tmp_path])
                    except KeyboardInterrupt:
                        # 2回目の Ctrl+C: ループを抜けて終了
                        print("\nDeleting temp file and exiting. Your original encrypted file is untouched.", file=sys.stderr)
                        break
    finally:
        # 一時ファイル削除
        Path(tmp_path).unlink(missing_ok=True)


def main():
    if len(sys.argv) < 2:
        print("Usage:", file=sys.stderr)
        print("  sshcrypt encrypt <plaintext> <encrypted>", file=sys.stderr)
        print("  sshcrypt decrypt <encrypted> <plaintext>", file=sys.stderr)
        print("  sshcrypt edit <file>", file=sys.stderr)
        sys.exit(1)
    
    command = sys.argv[1]
    
    try:
        if command == 'encrypt':
            if len(sys.argv) != 4:
                print("Usage: sshcrypt encrypt <plaintext> <encrypted>", file=sys.stderr)
                sys.exit(1)
            encrypt_file(sys.argv[2], sys.argv[3])
        
        elif command == 'decrypt':
            if len(sys.argv) != 4:
                print("Usage: sshcrypt decrypt <encrypted> <plaintext>", file=sys.stderr)
                sys.exit(1)
            decrypt_file(sys.argv[2], sys.argv[3])
        
        elif command == 'edit':
            if len(sys.argv) != 3:
                print("Usage: sshcrypt edit <file>", file=sys.stderr)
                sys.exit(1)
            edit_file(sys.argv[2])
        
        else:
            print(f"Unknown command: {command}", file=sys.stderr)
            print("Valid commands: encrypt, decrypt, edit", file=sys.stderr)
            sys.exit(1)
    
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
